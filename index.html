<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MovieTube</title>
    <!-- Carga de Tailwind CSS para el estilo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Configuraciones de fuente y fondo */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Estilos base para asegurar el tamaño de la aplicación */
        #root {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: #111827; /* bg-gray-900 */
        }
        /* Clase para ocultar el scrollbar en el reproductor si aparece */
        .no-scrollbar {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        .no-scrollbar::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }
        /* Estilo para el contenedor principal del reproductor para asegurar el foco */
        .player-container:focus {
             outline: none; /* Ocultar el molesto anillo de foco en el modo de pantalla completa */
        }

        /* Clases para animación de botones al enfocar/presionar */
        .control-button {
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4);
        }
        .control-button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.6);
        }
    </style>
    
    <!-- Carga de librerías React y Babel Standalone -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Carga del script del API de YouTube (Necesario globalmente) -->
    <script>
        var tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        var firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
    </script>
</head>
<body class="bg-gray-900 text-white min-h-screen no-scrollbar">
    <div id="root"></div>

    <!-- TODO EL CÓDIGO REACT/JSX VA AQUÍ -->
    <script type="text/babel">
        // Contenido completo de App.jsx
        import React, { useState, useEffect, useRef, useCallback } from 'react';
        import ReactDOM from 'react-dom/client';

        // ----------------------------------------------------------------------
        // UTILIDADES
        // ----------------------------------------------------------------------

        /**
         * Función para extraer el ID de YouTube y la información de la miniatura.
         * @param {string} url - URL del video.
         * @returns {{videoId: string | null, thumbnailUrl: string | null, isYouTube: boolean}}
         */
        const obtenerVideoInfo = (url) => {
            if (!url) return { videoId: null, thumbnailUrl: null, isYouTube: false };

            // Regex para URLs estándar y acortadas de YouTube
            const youtubeRegex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/ ]{11})/i;
            const match = url.match(youtubeRegex);
            
            const videoId = match ? match[1] : null;
            const isYouTube = !!videoId;

            let thumbnailUrl = 'https://placehold.co/600x337/333/fff?text=VIDEO+EXTERNO';
            if (isYouTube) {
                // Se intenta obtener la miniatura de alta calidad (maxresdefault)
                thumbnailUrl = `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;
            } else {
                // Para videos no-YouTube, se usa un placeholder genérico
                thumbnailUrl = 'https://placehold.co/600x337/333/fff?text=VIDEO+EXTERNO';
            }

            return { videoId, thumbnailUrl, isYouTube };
        };

        /**
         * Función para formatear el tiempo en segundos a formato MM:SS o HH:MM:SS.
         * @param {number} seconds - Tiempo en segundos.
         * @returns {string} Tiempo formateado.
         */
        const formatTime = (seconds) => {
            if (isNaN(seconds) || seconds < 0) return '0:00';
            const date = new Date(0);
            date.setSeconds(seconds);
            const timeString = date.toISOString().substring(11, 19);
            // Elimina el '00:' inicial si el video dura menos de una hora
            return seconds >= 3600 ? timeString : timeString.substring(3);
        };

        // ----------------------------------------------------------------------
        // REPRODUCTOR EN FOCO (CUSTOM CONTROLS)
        // ----------------------------------------------------------------------

        function ReproductorEnFoco({ videoUrl, onBack }) {
            const { videoId, isYouTube } = obtenerVideoInfo(videoUrl);
            
            // Estados del Reproductor Custom
            const [player, setPlayer] = useState(null);
            const [isPlayerReady, setIsPlayerReady] = useState(false);
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(0);
            const [isMuted, setIsMuted] = useState(false);
            const [bufferedPercent, setBufferedPercent] = useState(0);
            
            // Controles de UI
            const [showControls, setShowControls] = useState(true);
            const controlTimeoutRef = useRef(null);
            const playerContainerRef = useRef(null);
            const backButtonRef = useRef(null);

            // Velocidad de avance/retroceso en segundos
            const SEEK_TIME = 10;

            // 1. CARGA DEL API DE YOUTUBE (se ejecuta solo una vez al cargar el script)
            useEffect(() => {
                // Solo cargar si es un video de YouTube y la API no está cargada
                if (!isYouTube || window.YT) return;

                // Esta parte debería ser manejada por el <script> en el <head>, pero lo dejamos para robustez
                // const tag = document.createElement('script');
                // tag.src = "https://www.youtube.com/iframe_api";
                // const firstScriptTag = document.getElementsByTagName('script')[0];
                // firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

                // Define la función global de la API de YouTube
                window.onYouTubeIframeAPIReady = () => {
                    console.log('YouTube IFrame API Ready');
                    // Se asume que el player se creará en el siguiente useEffect
                };

                // Cleanup function
                return () => {
                    if (window.onYouTubeIframeAPIReady) {
                        delete window.onYouTubeIframeAPIReady;
                    }
                };
            }, [isYouTube]);

            // 2. INICIALIZACIÓN Y LIMPIEZA DEL PLAYER (se ejecuta al montar y cuando el videoId cambia)
            useEffect(() => {
                if (!isYouTube || !videoId || !window.YT) return;

                // Crea el reproductor de YouTube
                const createPlayer = () => {
                    const newPlayer = new window.YT.Player('youtube-player-container', {
                        videoId: videoId,
                        playerVars: {
                            'autoplay': 1,      // Iniciar automáticamente
                            'controls': 0,      // Ocultar controles nativos
                            'modestbranding': 1, // Sin el logo de YouTube grande
                            'rel': 0,           // No mostrar videos relacionados al final
                            'showinfo': 0,      // No mostrar título/información
                            'enablejsapi': 1    // Habilitar la API de JS
                        },
                        events: {
                            'onReady': onPlayerReady,
                            'onStateChange': onPlayerStateChange
                        }
                    });
                    setPlayer(newPlayer);
                };
                
                // Si el player ya existe y el videoId cambia, destrúyelo
                if (player) {
                    player.destroy();
                    setPlayer(null);
                }

                // Si la API está lista, crea el reproductor inmediatamente
                if (window.YT) {
                    createPlayer();
                } else {
                    // Si la API no está lista, espera a que esté
                    window.onYouTubeIframeAPIReady = () => {
                        createPlayer();
                        window.onYouTubeIframeAPIReady = null; // Limpiar la función global después de usarla
                    };
                }


                // Cleanup function
                return () => {
                    if (player) {
                        player.destroy();
                        setPlayer(null);
                    }
                    setIsPlayerReady(false);
                    setIsPlaying(false);
                    setDuration(0);

                    if (controlTimeoutRef.current) {
                        clearTimeout(controlTimeoutRef.current);
                    }
                };
            }, [videoId, isYouTube]); // Dependencias: ID de video e indicador de YouTube

            // 3. HANDLERS DE EVENTOS Y BUCLE DE ACTUALIZACIÓN
            
            // Evento onReady del Player
            const onPlayerReady = (event) => {
                setIsPlayerReady(true);
                // Enfocar el contenedor para capturar las pulsaciones de teclado inmediatamente.
                if (playerContainerRef.current) {
                    playerContainerRef.current.focus(); 
                }
                setDuration(event.target.getDuration());
                setIsMuted(event.target.isMuted());
                event.target.playVideo();
                updatePlayerState(event.target);
            };

            // Efecto para asegurar el foco inmediatamente al montar el componente
            useEffect(() => {
                // Asegura el foco en el contenedor al montar para capturar teclas inmediatamente.
                if (playerContainerRef.current) {
                    playerContainerRef.current.focus();
                }
                // Agregamos un listener para re-enfocar si el foco se pierde accidentalmente
                const handleBlur = () => {
                    // Solo intentar re-enfocar si el reproductor está activo
                    // setTimeout(() => playerContainerRef.current?.focus(), 50);
                };

                const container = playerContainerRef.current;
                container?.addEventListener('blur', handleBlur, true); // true para fase de captura
                
                return () => {
                    container?.removeEventListener('blur', handleBlur, true);
                };
            }, [videoId]);


            // Evento onStateChange del Player
            const onPlayerStateChange = (event) => {
                // Los estados: -1 (Unstarted), 0 (Ended), 1 (Playing), 2 (Paused), 3 (Buffering), 5 (Cued)
                if (event.data === window.YT.PlayerState.PLAYING) {
                    setIsPlaying(true);
                    resetControlTimeout(); // Reiniciar el timeout al empezar a reproducir
                } else if (event.data === window.YT.PlayerState.PAUSED) {
                    setIsPlaying(false);
                    resetControlTimeout(true); // Mostrar controles indefinidamente al pausar
                } else if (event.data === window.YT.PlayerState.ENDED) {
                    setIsPlaying(false);
                    resetControlTimeout(true);
                } 
                // No es necesario manejar BUFFERING aquí, ya que el estado PLAYING lo cubrirá al reanudar
            };

            // Bucle para actualizar el tiempo cada 250ms
            useEffect(() => {
                let interval;
                if (isPlayerReady && isPlaying) {
                    interval = setInterval(() => {
                        if (player) {
                            updatePlayerState(player);
                        }
                    }, 250);
                } else {
                    clearInterval(interval);
                }
                return () => clearInterval(interval);
            }, [isPlayerReady, isPlaying, player]);

            // Función de actualización de estado del player
            const updatePlayerState = (p) => {
                setCurrentTime(p.getCurrentTime());
                // Cálculo del porcentaje de buffer:
                const loadedTime = p.getLoadedFraction() * p.getDuration();
                const bufferPercent = p.getDuration() > 0 ? (loadedTime / p.getDuration()) * 100 : 0;
                setBufferedPercent(bufferPercent);

                // Sincronizar estado de mute
                setIsMuted(p.isMuted());
            };

            // 4. FUNCIONES DE CONTROL DEL REPRODUCTOR
            
            const resetControlTimeout = useCallback((permanent = false) => {
                if (controlTimeoutRef.current) {
                    clearTimeout(controlTimeoutRef.current);
                }
                setShowControls(true);
                if (!permanent) {
                    // Ocultar controles después de 3 segundos de inactividad
                    controlTimeoutRef.current = setTimeout(() => {
                        setShowControls(false);
                    }, 3000);
                }
            }, []);

            const togglePlayPause = useCallback(() => {
                if (!player || !isPlayerReady) return;

                if (isPlaying) {
                    player.pauseVideo();
                } else {
                    player.playVideo();
                }
                // El estado isPlaying se actualizará en onPlayerStateChange
                resetControlTimeout();
            }, [player, isPlayerReady, isPlaying, resetControlTimeout]);

            const rewind = useCallback(() => {
                if (!player || !isPlayerReady) return;
                const newTime = Math.max(0, currentTime - SEEK_TIME);
                player.seekTo(newTime, true);
                setCurrentTime(newTime);
                resetControlTimeout();
            }, [player, isPlayerReady, currentTime, resetControlTimeout]);

            const fastForward = useCallback(() => {
                if (!player || !isPlayerReady) return;
                const newTime = Math.min(duration, currentTime + SEEK_TIME);
                player.seekTo(newTime, true);
                setCurrentTime(newTime);
                resetControlTimeout();
            }, [player, isPlayerReady, currentTime, duration, resetControlTimeout]);

            const toggleMute = useCallback(() => {
                if (!player || !isPlayerReady) return;
                if (isMuted) {
                    player.unMute();
                } else {
                    player.mute();
                }
                setIsMuted(!isMuted); // Actualizar inmediatamente el estado de la UI
                resetControlTimeout();
            }, [player, isPlayerReady, isMuted, resetControlTimeout]);

            const handleSeek = useCallback((e) => {
                if (!player || !isPlayerReady || duration === 0) return;

                const rect = e.currentTarget.getBoundingClientRect();
                const clickPositionX = e.clientX - rect.left;
                const percentage = clickPositionX / rect.width;
                const newTime = duration * percentage;
                
                player.seekTo(newTime, true);
                setCurrentTime(newTime);
                resetControlTimeout();
            }, [player, isPlayerReady, duration, resetControlTimeout]);

            const handleOnBack = useCallback(() => {
                if (player) {
                    // Asegúrate de que el reproductor se detenga antes de salir
                    player.stopVideo(); 
                }
                onBack();
            }, [onBack, player]);

            // LÓGICA DE TECLADO 
            const handleKeyDown = (e) => {
                // --- PARA DEPURACIÓN: Comprueba si esta función se está ejecutando ---
                console.log('Tecla presionada:', e.key);
                // ---------------------------------------------------------------------

                // Mantiene el foco en el contenedor del reproductor y gestiona el timeout de los controles
                resetControlTimeout(); 
                
                // Maneja las teclas de control primarias (D-Pad, Enter/Space, Mute)
                switch (e.key) {
                    case 'Enter':
                    case ' ': 
                        e.preventDefault(); 
                        togglePlayPause();
                        break;
                    case 'ArrowLeft': 
                        e.preventDefault(); 
                        rewind();
                        break;
                    case 'ArrowRight': 
                        e.preventDefault(); 
                        fastForward();
                        break;
                    // ----------------------------------------------------
                    // TECLAS PARA VOLVER:
                    // ----------------------------------------------------
                    case 'Escape': 
                    case 'Backspace': 
                    case 'ArrowUp': 
                        e.preventDefault();
                        handleOnBack(); // Llama a la función de volver al catálogo
                        break;
                    // ----------------------------------------------------
                    case 'm': // Tecla 'm' para mutear (común en reproductores web)
                        toggleMute();
                        break;
                    default:
                        break;
                }
            };

            // Cálculo del porcentaje de progreso (proporcionado por el usuario)
            const progressPercent = duration > 0 ? (currentTime / duration) * 100 : 0;
            
            // ICONOS (SVG)
            const BackIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 19l-7-7m0 0l7-7m-7 7h18" /></svg>;
            const PlayIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4.004a1 1 0 001.555.832l3.224-2.002a1 1 0 000-1.664l-3.224-2.002z" clipRule="evenodd" /></svg>;
            const PauseIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 011 1v4a1 1 0 11-2 0V7a1 1 0 011-1zm-3 4a1 1 0 002 0V7a1 1 0 00-2 0v4z" clipRule="evenodd" /></svg>;
            const VolumeIcon = () => isMuted ? 
                <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.217zm10.024 2.193a1 1 0 010 1.414L17.243 10l2.164 2.163a1 1 0 01-1.414 1.414L15.829 11.414l-2.163 2.164a1 1 0 01-1.414-1.414L14.414 10l-2.163-2.163a1 1 0 011.414-1.414l2.163 2.164 2.164-2.163a1 1 0 011.414 0z" clipRule="evenodd" /></svg>
                :
                <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.217zM14.657 5.059a1 1 0 011.414 0 9 9 0 010 12.582 1 1 0 11-1.414-1.414 7 7 0 000-9.754 1 1 0 010-1.414zM16.071 3.645a1 1 0 011.414 0 11 11 0 010 15.69 1 1 0 11-1.414-1.414 9 9 0 000-12.862 1 1 0 010-1.414z" clipRule="evenodd" /></svg>;
            const RewindIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M8.445 14.832A1 1 0 0010 14V6a1 1 0 00-1.555-.832l-6 4a1 1 0 000 1.664l6 4zM14.445 14.832A1 1 0 0016 14V6a1 1 0 00-1.555-.832l-6 4a1 1 0 000 1.664l6 4z" /></svg>;
            const FastForwardIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M4.555 5.168A1 1 0 003 6v8a1 1 0 001.555.832l6-4a1 1 0 000-1.664l-6-4zM10.555 5.168A1 1 0 009 6v8a1 1 0 001.555.832l6-4a1 1 0 000-1.664l-6-4z" /></svg>;

            // Mostrar un indicador de carga mientras el player se prepara
            if (isYouTube && !isPlayerReady) {
                return (
                    <div className="fixed inset-0 bg-black z-50 flex items-center justify-center">
                        <div className="text-white text-xl flex flex-col items-center">
                            <svg className="animate-spin -ml-1 mr-3 h-10 w-10 text-red-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <p className="mt-4">Cargando reproductor de YouTube...</p>
                        </div>
                    </div>
                );
            }

            return (
                <div 
                    ref={playerContainerRef}
                    className="player-container fixed inset-0 bg-black z-50 flex flex-col items-center justify-center"
                    onClick={resetControlTimeout} 
                    onKeyDown={handleKeyDown} 
                    tabIndex={0} 
                    // Esto es crucial para que el contenedor pueda recibir eventos de teclado
                    style={{outline: 'none', background: 'black'}} 
                >
                    <div className="w-full h-full flex flex-col items-center justify-center relative">
                        <div className="w-full h-full max-w-screen-xl max-h-[80vh] relative flex items-center justify-center">
                            <div 
                                id="youtube-player-container" 
                                tabIndex="-1" 
                                // Se ajusta el contenedor para ser un aspect-video y centrado
                                className="w-full h-full aspect-video rounded-xl shadow-2xl bg-gray-900 overflow-hidden"
                                // Estilo para asegurar que el iframe ocupe todo el espacio de su contenedor
                                style={{ aspectRatio: '16 / 9', maxWidth: '100%', maxHeight: '100%' }} 
                            >
                                {/* Se renderiza el iframe para videos NO-YouTube */}
                                {!isYouTube && (
                                    <iframe
                                        tabIndex="-1" 
                                        className="youtube-iframe rounded-xl shadow-2xl bg-gray-900 w-full h-full"
                                        src={videoUrl}
                                        allow="autoplay; fullscreen"
                                        allowFullScreen
                                        title="Video Externo"
                                    ></iframe>
                                )}
                                {/* Para videos de YouTube, el API crea un iframe dentro del div#youtube-player-container */}
                            </div>
                        </div>

                        {/* CONTROLES COMPLETOS (Barra + Botones + Tiempos) */}
                        {/* Nota: Los controles solo se muestran para el reproductor de YouTube con controles customizados */}
                        {isYouTube && (
                            <div 
                                className={`absolute bottom-10 w-full max-w-xl flex flex-col p-4 rounded-xl shadow-2xl 
                                        transition-opacity duration-300 ${showControls ? 'opacity-100 bg-gray-800/80' : 'opacity-0 pointer-events-none'}
                                        ${isPlayerReady ? '' : 'hidden'}`} // Ocultar si el player no está listo
                            >
                                {/* BARRA DE PROGRESO */}
                                <div 
                                    onClick={handleSeek}
                                    className="progress-bar-container w-full bg-gray-600 rounded-full cursor-pointer group mb-2 h-1.5 relative"
                                    // tabIndex solo debe estar activo si los controles son visibles
                                    tabIndex={showControls ? 0 : -1} 
                                    title="Barra de Progreso (Click para Saltar)"
                                >
                                    {/* INDICADOR DE BUFFER */}
                                    <div 
                                        className="absolute top-0 left-0 h-full bg-gray-400 opacity-50 rounded-full" 
                                        style={{ width: `${bufferedPercent}%` }}
                                    ></div>

                                    {/* INDICADOR DE TIEMPO REPRODUCIDO */}
                                    <div 
                                        className="progress-fill bg-red-600 rounded-full group-hover:bg-red-500 relative h-full" 
                                        style={{ width: `${progressPercent}%` }}
                                    ></div>
                                </div>

                                {/* TIEMPOS */}
                                <div className="flex justify-between text-sm font-mono text-gray-300 mb-4">
                                    <span>{formatTime(currentTime)}</span>
                                    <span>{formatTime(duration)}</span>
                                </div>

                                {/* Botones de Control */}
                                <div className="flex justify-center space-x-4">
                                    <button 
                                        onClick={handleOnBack}
                                        ref={backButtonRef}
                                        className="control-button text-white p-2 rounded-full bg-red-600 hover:bg-red-700 
                                                    focus:ring-4 focus:ring-white focus:outline-none"
                                        // Asegura que el botón sea navegable solo si los controles están visibles
                                        tabIndex={showControls ? 0 : -1} 
                                        title="Volver al Catálogo (Escape / Flecha Arriba)"
                                    >
                                        <BackIcon />
                                    </button>

                                    <button 
                                        onClick={rewind}
                                        className="control-button text-white p-2 rounded-full bg-gray-600 hover:bg-gray-700 
                                                    focus:ring-4 focus:ring-white focus:outline-none"
                                        tabIndex={showControls ? 0 : -1}
                                        title="Retroceder 10 segundos (Tecla Izquierda)"
                                    >
                                        <RewindIcon />
                                    </button>

                                    <button 
                                        onClick={togglePlayPause}
                                        className="control-button text-white p-2 rounded-full bg-red-600 hover:bg-red-700 
                                                    focus:ring-4 focus:ring-white focus:outline-none"
                                        tabIndex={showControls ? 0 : -1}
                                        title={isPlaying ? "Pausar (Tecla Enter/Espacio)" : "Reproducir (Tecla Enter/Espacio)"}
                                    >
                                        {isPlaying ? <PauseIcon /> : <PlayIcon />}
                                    </button>

                                    <button 
                                        onClick={toggleMute}
                                        className="control-button text-white p-2 rounded-full bg-gray-600 hover:bg-gray-700 
                                                    focus:ring-4 focus:ring-white focus:outline-none"
                                        tabIndex={showControls ? 0 : -1}
                                        title={isMuted ? "Desactivar silencio" : "Silenciar"}
                                    >
                                        <VolumeIcon />
                                    </button>

                                    <button 
                                        onClick={fastForward}
                                        className="control-button text-white p-2 rounded-full bg-gray-600 hover:bg-gray-700 
                                                    focus:ring-4 focus:ring-white focus:outline-none"
                                        tabIndex={showControls ? 0 : -1}
                                        title="Avanzar 10 segundos (Tecla Derecha)"
                                    >
                                        <FastForwardIcon />
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        // ----------------------------------------------------------------------
        // COMPONENTES HERO BANNER Y TARJETA 
        // ----------------------------------------------------------------------

        const HeroBanner = React.forwardRef(({ titulo, descripcion, videoUrl, onPlay }, ref) => {
            const { thumbnailUrl } = obtenerVideoInfo(videoUrl);
            const genericPlaceholderUrl = "https://placehold.co/1920x1080/0d1117/333?text=CARGANDO...";

            return (
                <div 
                    className="hero-background w-full min-h-[50vh] flex items-end relative overflow-hidden mb-8 rounded-xl shadow-2xl bg-cover bg-center"
                    tabIndex="-1" 
                    style={{ 
                        backgroundImage: `linear-gradient(rgba(0,0,0,0.1), rgba(0,0,0,0.8)), url('${thumbnailUrl}'), url('${genericPlaceholderUrl}')`,
                        // Ajustes para que la imagen de fondo cubra bien el área
                        backgroundSize: 'cover',
                        backgroundPosition: 'center',
                    }}
                >
                    <div className="relative p-8 max-w-xl">
                        <h2 className="text-4xl font-extrabold mb-2 text-white drop-shadow-lg">
                            {titulo}
                        </h2>
                        <p className="text-base mb-4 text-gray-200 drop-shadow-md">
                            {descripcion}
                        </p>

                        <button 
                            ref={ref}
                            onClick={() => onPlay(videoUrl)} 
                            className="inline-block px-6 py-2 bg-red-600 text-white font-bold rounded-lg shadow-lg 
                                        transition-all duration-300 hover:bg-red-700 
                                        focus:ring-4 focus:ring-white focus:ring-offset-2 focus:ring-offset-gray-900 focus:outline-none"
                            tabIndex="0" 
                        >
                            Ver Ahora
                        </button>
                    </div>
                </div>
            );
        });
        HeroBanner.displayName = 'HeroBanner';


        function ReproductorDeVideo(props) {
            const { videoId, thumbnailUrl, isYouTube } = obtenerVideoInfo(props.url);
            const genericPlaceholderUrl = "https://placehold.co/600x337/333/fff?text=VIDEO+EXTERNO";

            // Maneja errores de carga de miniaturas, cayendo a una imagen de baja calidad o a un placeholder genérico
            const handleImageError = (e) => {
                e.target.onerror = null; 
                if (isYouTube && videoId && e.target.src.includes('maxresdefault')) {
                    e.target.src = `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
                    return;
                } 
                e.target.src = genericPlaceholderUrl;
            };

            return (
                <div 
                    className="video-card cursor-pointer group relative overflow-hidden bg-gray-800 rounded-xl shadow-lg 
                                transition-all duration-300 hover:shadow-2xl hover:scale-[1.03] 
                                focus:ring-4 focus:ring-red-500 focus:outline-none"
                    onClick={() => props.onPlay(props.url)} 
                    tabIndex="0" 
                >
                    <img 
                        src={thumbnailUrl} 
                        onError={handleImageError} 
                        className="w-full aspect-video object-cover transition duration-500 group-hover:opacity-75"
                        alt={`Miniatura de ${props.titulo}`}
                    />

                    <div className="p-3">
                        <h2 className="text-base font-semibold text-red-400 group-focus:text-red-300 line-clamp-2">
                            {props.titulo || "Título del Video"}
                        </h2>
                        <p className="mt-1 text-gray-400 text-xs">
                            Fuente: {isYouTube ? "YouTube" : "Externa"}
                        </p>
                    </div>

                </div>
            );
        }

        // ----------------------------------------------------------------------
        // COMPONENTE PRINCIPAL APP
        // ----------------------------------------------------------------------

        function App() {
            // Estado para saber qué video está en reproducción/foco
            const [videoEnFocoUrl, setVideoEnFocoUrl] = useState(null);
            const heroButtonRef = useRef(null); 

            // Callback para volver al catálogo y restaurar el foco al botón principal
            const handleBack = useCallback(() => {
                setVideoEnFocoUrl(null);
                // Usar setTimeout para permitir que la vista se re-renderice antes de intentar enfocar
                setTimeout(() => {
                    if (heroButtonRef.current) {
                        heroButtonRef.current.focus();
                    }
                }, 0);
            }, []);


            if (videoEnFocoUrl) {
                return <ReproductorEnFoco 
                    videoUrl={videoEnFocoUrl} 
                    onBack={handleBack} 
                />;
            }

            // Video de prueba
            const heroVideoUrl ="https://youtu.be/bd7PTHImmaI?si=95uXGaIK9s9eZPpS";

            return (
                <div className="p-4 md:p-8 max-w-7xl mx-auto min-h-screen font-sans bg-gray-900 text-white">
                    <HeroBanner 
                        ref={heroButtonRef}
                        titulo="Estreno de la Semana"
                        descripcion="Controles D-Pad funcionales y catálogo optimizado."
                        videoUrl={heroVideoUrl}
                        onPlay={setVideoEnFocoUrl} 
                    />

                    <h1 className="text-2xl font-bold mb-4 text-red-600">
                        Películas Recomendadas
                    </h1>

                    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
                        <ReproductorDeVideo titulo="Nephilim" url={heroVideoUrl} onPlay={setVideoEnFocoUrl} />
                        <ReproductorDeVideo titulo="Simbad la aventura del minotauro" url="https://youtu.be/_k3CPvhzEVA?si=HUYPMxQi2Az3sK9N" onPlay={setVideoEnFocoUrl} />
                        <ReproductorDeVideo titulo="Alien Convergence" url="https://youtu.be/w6DKhpKjMTE?si=j-7kNNoz93l0UZk9" onPlay={setVideoEnFocoUrl} />
                        <ReproductorDeVideo titulo="Yeti el hombre de la nieve" url="https://youtu.be/_OWD2gaWdOM?si=M-7yKl2zS51hCOvf" onPlay={setVideoEnFocoUrl} />
                        <ReproductorDeVideo titulo="D-railed" url="https://youtu.be/Ggz2LT9hVb0?si=UYnxkh9g7UH1G8uB" onPlay={setVideoEnFocoUrl} />
                        <ReproductorDeVideo titulo="The Last Sharknado: It's About Time" url="https://www.youtube.com/watch?v=Fj-y5gN-FvA" onPlay={setVideoEnFocoUrl} />
                        <ReproductorDeVideo titulo="Deep Blue Sea 3" url="https://www.youtube.com/watch?v=68fJ66Uv2O4" onPlay={setVideoEnFocoUrl} />
                        {/* Ejemplo de video externo, no de YouTube */}
                        <ReproductorDeVideo titulo="Another Sci-Fi Movie (External)" url="https://www.w3schools.com/html/mov_bbb.mp4" onPlay={setVideoEnFocoUrl} /> 
                    </div>
                </div>
            );
        }

        // Montaje de la aplicación
        const rootElement = document.getElementById('root');
        // Usar la función de inicialización de React 18
        if (rootElement) {
            const root = ReactDOM.createRoot(rootElement);
            root.render(<App />);
        }
    </script>
</body>
</html>
